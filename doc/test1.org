#+title: A little sugar with your Clojure Aspect Contracts
#+tags: clojure aspect contract sugar
#+options: H:4 toc:3
#+options: ^:{}
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+OCTOPRESS_CATEGORIES: clojure aspect contract sugar
#+OCTOPRESS_COMMENTS: getting started with clojure-contracts-sugar
#+PROPERTY: :mkdirp yes
#+PROPERTY: :tangle ../examples/aspect-examples/src/main/clojure/aspect_examples1.clj
#+OPTIONS: texht:t
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+BEGIN_QUOTE
TL;DR: clojure-contracts-sugar - some sugar  macros for clojure.core.contracts
#+END_QUOTE

* Introduction
 
Back in November 2012, in one of my first toe-dippings into
[Clojure][ClojureHome], I wrote a
[post][RumfordBlogClojureCoreContractsFirstTake] on my initial experiences
with [Michael Fogus's][FogusHome]
[clojure.core.contracts][ClojureCoreContractsGithub] (hereafter just
*CCC*).

The rest of this post assumes you have a passing familiarity with
*CCC*. If you aren't, you may find my 
[original post][RumfordBlogClojureCoreContractsFirstTake] a digestible introduction.

Although using *CCC* for
_[contracts programming][DesignByContractWikipedia]_ is self-evident,
it was the opportunity to use the [Clojure's][ClojureHome]
[:pre and :post assertions][FogusBlogClojurePreandPost] to support the
concept and potential of _aspects_ as defined originally by
[Gregor Kiczales][KiczalesHome] in his work on
[Aspect Oriented Programming][AOPWikipedia] (*AOP*).

In this post I'm following through the experiments and ideas of the
[original post][RumfordBlogClojureCoreContractsFirstTake], and
illustrating with some examples using a new library
I've written recently - [clojure-contracts-sugar][ClojureContractsSugarGithub] (*CHUGAR*).

In the [original post][RumfordBlogClojureCoreContractsFirstTake] I made the point that *CCC* could do with some
productivity aids - _sugar_ - to ease the rich usage of *CCC*. *CHUGAR*
attempts to supply that _sugar_ and you can think of this post as
partly a _getting started_ tutorial for the library.

In the simplest cases, *CHUGAR* reduces to *CCC* albeit with a slightly
more flexible syntax. If your contracts needs are straightforward, you're
likely better off using *CCC* or even [:pre and :post assertions][Fogusblogclojurepreandpost] 
directly.

That said, I would encourage you though to have a look at the sections
on _mnemonics_ below which offer an easy way to use (and re-use) rich
and flexible aspect contracts.

Note, the usual caveat,  *CHUGAR*  is a work in progress and really is
intended to be only a starting point (foundation) for  explorations of
contracts from [Clojure][ClojureHome].  The API is "settling" but may change.

#+BEGIN_QUOTE
A quick note on terminology: in the [original
post][RumfordBlogClojureCoreContractsFirstTake] I used *suck* to identify
the (input) arguments of a function and *spit* the result (return value). That
"convention" is used extensively both here and in the library's code.
#+END_QUOTE

#+BEGIN_SRC clojure
<!-- more -->
#+END_SRC

* Aspect Oriented Programming

I first bumped into *AOP* reading the *Communications of the ACM's*
[October 2001 edition][CACMOct2001] special edition on AOP (paywall
for content). In their [introductory article][CACMArticleAOPIntro] in
that volume, _Elrad, Filman and Bader_ explains the need for AOP like
so:

#+BEGIN_QUOTE
Any structural realization of a system will find that some concerns
are neatly localized within a specific structural piece, while others
cross multiple elements. AOP is focused on mechanisms for simplifying
the realization of such crosscutting concerns.
#+END_QUOTE

and

#+BEGIN_QUOTE
Separating the expressions of multiple concerns in programming
systems promises simpler system evolution, more comprehensible
systems, adaptability, customizability, and easier reuse. 
#+END_QUOTE

They go on to highlight the opportunity for a services paradigm for
common requirements such as authentication, logging, etc facilitating
clear separation of concerns: Leaving the application developers to
focus of their agenda whilst minimising the potential for "misuse",
whether by omission or commission, of the specialist subsystems e.g. authentication
which may be  supported by  other, third,  parties:

#+BEGIN_QUOTE
Implicit invocation is a virtue in this age of increased software
complexity, as domain experts for an application are unlikely to be
familiar with intricacies of specialized algorithms for distribution,
authentication, access control, synchronization, encryption,
redundancy, and so forth, and cannot be trusted to always invoke them
appropriately in their programs.
#+END_QUOTE

In [Ramnivas Laddad's][LaddadTwitter]  [book on AspectJ][LaddadBookAspectJinAction], he says:

#+BEGIN_QUOTE
AOP is a new methodology that provides separation of crosscutting concerns
by introducing a new unit of modularization—an aspect—that crosscuts other
modules. With AOP you implement crosscutting concerns in aspects instead of
fusing them in the core modules.
#+END_QUOTE

#+BEGIN_QUOTE
The result is that AOP modularizes the cross-cutting concerns in a
clear-cut fashion, yielding a system architecture that is easier to
design, implement, and maintain.
#+END_QUOTE

In another take, in [Emerick][EmerickHome], [Carper][CarperHome] and [Grand's][GrandHome]  book [Clojure Programming][ClojureProgrammingBook], they say:

#+BEGIN_QUOTE
Aspect-oriented programming (AOP) is a methodology that allows separation of cross-cutting
concerns. In object-oriented code, a behavior or process is often repeated in
multiple classes, or spread across multiple methods. AOP is a way to abstract this
behavior and apply it to classes and methods without using inheritance.
#+END_QUOTE

