<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>A little sugar with your Clojure Aspect Contracts</title>
<!-- 2014-01-30 Thu 18:41 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Ian Rumford" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">A little sugar with your Clojure Aspect Contracts</h1>
<blockquote>
<p>
TL;DR: clojure-contracts-sugar - some sugar  macros for clojure.core.contracts
</p>
</blockquote>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Back in November 2012, in one of my first toe-dippings into
[Clojure][ClojureHome], I wrote a
[post][RumfordBlogClojureCoreContractsFirstTake] on my initial experiences
with [Michael Fogus's][FogusHome]
[clojure.core.contracts][ClojureCoreContractsGithub] (hereafter just
<b>CCC</b>).
</p>

<p>
The rest of this post assumes you have a passing familiarity with
<b>CCC</b>. If you aren't, you may find my previous
[post][RumfordBlogClojureCoreContractsFirstTake] a digestible introduction.
</p>

<p>
Although using <b>CCC</b> for
<span class="underline">[contracts programming][DesignByContractWikipedia]</span> is self-evident,
it was the opportunity to use the [Clojure's][ClojureHome]
[:pre and :post assertions][FogusBlogClojurePreandPost] to support the
concept and potential of <span class="underline">aspects</span> as defined originally by
[Gregor Kiczales][KiczalesHome] in his work on
[Aspect Oriented Programming][AOPWikipedia] (<b>AOP</b>).
</p>

<p>
In this post I'm following through the experiments and ideas using <span class="underline">aspects</span>
described in the
[original post][RumfordBlogClojureCoreContractsFirstTake], and illustrating with some examples of a new library
([clojure-contracts-sugar][ClojureContractsSugarGithub] - <b>CHUGAR</b>)
I've written recently.
</p>

<p>
In the [original post][RumfordBlogClojureCoreContractsFirstTake] I made the point that <b>CCC</b> could do with some
productivity aids - <span class="underline">sugar</span> - to ease the rich usage of <b>CCC</b>. <b>CHUGAR</b>
attempts to supply that <span class="underline">sugar</span> and you can think of this post as
partly a <span class="underline">getting started</span> tutorial for the library.
</p>

<p>
This may seems a bit dry, even academic ("Where the beef?",
"What does this offer over Core Contracts?" and "Why would I
bother?"), so I'll follow up with posts giving practical examples of
the library's usage (one will be about the need that made
me build out <b>CHUGAR</b> in the first place).
</p>

<p>
In the simplest cases, <b>CHUGAR</b> reduces to <b>CCC</b> albeit with a slightly
simpler syntax. If your contracts needs are straightforward, you're
likely better off using [:pre and :post assertions][Fogusblogclojurepreandpost] 
directly or <b>CCC</b> if you want
to decouple the contract from the function and treat the former as an
<span class="underline">aspect</span>.  
</p>

<p>
That said, I would encourage you though to have a look at the sections
on <span class="underline">mnemonics</span> below which offer an easy way to use (and re-use) rich
and flexible aspect contracts.
</p>

<p>
Note, the usual caveat,  <b>CHUGAR</b>  is a work in progress and is
intended to be a starting point (foundation) for more explorations of
contracts from [Clojure][ClojureHome].  The API is "settling" but may change.
</p>

<blockquote>
<p>
A quick note on terminology: in the [original
post][RumfordBlogClojureCoreContractsFirstTake] I used <b>suck</b> to identify
the (input) arguments of a function and <b>spit</b> the return value. That
"convention" is used extensively both here and in the code.
</p>
</blockquote>

<pre class="example">
&lt;!-- more --&gt;
</pre>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Aspect Oriented Programming</h2>
<div class="outline-text-2" id="text-2">
<p>
I first bumped into <b>AOP</b> in the <b>Communications of the ACM's</b>
[October 2001 edition][CACMOct2001] special edition on AOP (paywall
for content). In their [introductory article][CACMArticleAOPIntro] in
that volume, <span class="underline">Elrad, Filman and Bader</span> explains the need for AOP like
so:
</p>

<blockquote>
<p>
Any structural realization of a system will find that some concerns
are neatly localized within a specific structural piece, while others
cross multiple elements. AOP is focused on mechanisms for simplifying
the realization of such crosscutting concerns.
</p>
</blockquote>

<p>
and
</p>

<blockquote>
<p>
Separating the expressions of multiple concerns in programming
systems promises simpler system evolution, more comprehensible
systems, adaptability, customizability, and easier reuse. 
</p>
</blockquote>

<p>
They go on to highlight the opportunity for a services paradigm for common requirements such as authentication, logging, etc facilitating clear separation of concerns: Leaving the application developers to focus of their agenda whilst minimising the potential for "misuse", whether by omission or commission, of the e.g. authentication API perhaps supported by a specialist security team:
</p>

<blockquote>
<p>
Implicit invocation is a virtue in this age of increased software
complexity, as domain experts for an application are unlikely to be
familiar with intricacies of specialized algorithms for distribution,
authentication, access control, synchronization, encryption,
redundancy, and so forth, and cannot be trusted to always invoke them
appropriately in their programs.
</p>
</blockquote>

<p>
In [Ramnivas Laddad's][LaddadTwitter]  [book on AspectJ][LaddadBookAspectJinAction], he says:
</p>

<blockquote>
<p>
AOP is a new methodology that provides separation of crosscutting concerns
by introducing a new unit of modularization—an aspect—that crosscuts other
modules. With AOP you implement crosscutting concerns in aspects instead of
fusing them in the core modules.
</p>
</blockquote>

<blockquote>
<p>
The result is that AOP modularizes the cross-cutting concerns in a
clear-cut fashion, yielding a system architecture that is easier to
design, implement, and maintain.
</p>
</blockquote>

<p>
In another take, in [Emerick][EmerickHome], [Carper][CarperHome] and [Grand's][GrandHome]  book [Clojure Programming][ClojureProgrammingBook], they say:
</p>

<blockquote>
<p>
Aspect-oriented programming (AOP) is a methodology that allows separation of cross-cutting
concerns. In object-oriented code, a behavior or process is often repeated in
multiple classes, or spread across multiple methods. AOP is a way to abstract this
behavior and apply it to classes and methods without using inheritance.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> The Code</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Jar is on Clojars</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The jar is current only on [Clojars][ClojarsHome]:
</p>

<p>
[Leiningen][LeiningenHome] dependency information:
</p>

<div class="org-src-container">

<pre class="src src-clojure">[name.rumford/clojure-contracts-sugar "0.1.0"]
</pre>
</div>

<p>
[Maven][MavenHome] dependency information:
</p>

<div class="org-src-container">

<pre class="src src-xml">&lt;dependency&gt;
  &lt;groupId&gt;name.rumford&lt;/groupId&gt;
  &lt;artifactId&gt;clojure-contracts-sugar&lt;/artifactId&gt;
  &lt;version&gt;0.1.0&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Repo is on Github</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The [repo][ClojureContractsSugarGithub] is  on [github][ClojureContractsSugarGithub].
As is common with Clojure code bases, its organised as a [Leiningen][LeiningenHome]
project so you'll need Leiningen [installed][LeiningenGithub] to work.
</p>

<p>
The project structure is Maven style but there is only Clojure today:
<span class="underline">./src/main/clojure</span> and <span class="underline">./src/test/clojure</span>.
</p>

<p>
The code uses another of my other new libraries
[clojure-carp][ClojureCarpGithub] for some utility functions,  exceptions, diagnostics and
other miscellany.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Overview</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The repo's <span class="underline">./doc</span> folder contains the source of this post: it is an
[emacs][emacshome] [org][orgmodehome] file
[tangled][orgmodemanualextractsourcecode] to generate the examples
project.
</p>

<p>
It also contains an (org) file <span class="underline">code overview.org</span> offering a high-level overview of the
code's artefacts.
</p>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Tests</h3>
<div class="outline-text-3" id="text-3-4">
<p>
There are a number of tests providing reasonable code coverage that can be run from the repo:
</p>

<div class="org-src-container">

<pre class="src src-bash">lein test aspect-tests1
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Examples</h3>
<div class="outline-text-3" id="text-3-5">
<p>
The examples below can be found in the repo's examples folder
(specifically in <span class="underline">./examples/aspect_examples</span>) and they can be run using
<span class="underline">lein</span> in the usual way:
</p>

<div class="org-src-container">

<pre class="src src-bash">cd ./examples/aspect-examples
lein deps
lein run -m aspect-examples1
</pre>
</div>

<p>
The examples use a couple of harness functions - <span class="underline">will-work</span> and
<span class="underline">will-fail</span> - to run tests.
</p>

<p>
<span class="underline">will-work</span> takes as arguments the constrained
function and a list of the accessor's arguments. 
</p>

<p>
<span class="underline">will-fail</span> similarly takes just the constrained function and its arguments and
catches the <b>AssertionError</b> expected to be thrown.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Helper for accessor examples expected to work.  Returns the expected result, else fails

(defn will-work
  [fn-constrained &amp; fn-args]
  (let [actual-result (apply fn-constrained fn-args)]
    (println "will-work" "worked as expected" "actual-result" actual-result "fn-constrained" fn-constrained "fn-args" fn-args)
    actual-result))

;; Helper for accessor examples expected to fail.  Catches the expected AssertionError, else fails.
;; A nil return from the function is ok

(defn will-fail
  [fn-constrained &amp; fn-args]
  (try
    (do
      (let [return-value (apply fn-constrained fn-args)]
        (if return-value (assert (println "will-fail" "DID NOT FAIL" "did not cause AssertionError" "fn-constrained" fn-constrained "fn-args" fn-args "RETURN-VALUE" (class return-value) return-value)))))
    (catch AssertionError e
      (println "will-fail" "failed as expected" "fn-constrained" fn-constrained "fn-args" fn-args))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Using Contract Aspects - Apply v Update</h2>
<div class="outline-text-2" id="text-4">
<p>
The libary has two main macros: <span class="underline">apply-contract-aspects</span> and
<span class="underline">update-contract-aspects</span>.  
</p>

<p>
The majority of examples below  use <span class="underline">apply-contract-aspects</span> but <span class="underline">update-contract-aspects</span> could be used just as well.
</p>

<p>
A couple of very simple examples follow to give a <span class="underline">flavour</span> of their usage and details will be expanded upon in the following sections.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Using apply-contract-aspects</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The first, <span class="underline">apply-contract-aspects</span>, applies one or more aspects to an
existing function and returns a <b>new</b> function.  
</p>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> Example - applying a built-in predicate</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
The below will create, from the original function
<span class="underline">any-fn</span>, a new constrained function <span class="underline">map-fn</span> that will <b>only</b> suck a
map as its input argument.  (The return value will be unconstrained.)
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - applying a built-in predicate

;; any-fn is the "base" function

(defn any-fn [x] x)

;; map-fn is the new function constrained to suck a map

(def suck-map-fn1 (apply-contract-aspects any-fn map?))

;; This will work

(will-work suck-map-fn1 {:a 1 :b 2 :c 3})

;; But this will fail since suck-map-fn1 can only suck a map

(will-fail suck-map-fn1 [1 2 3])

;; The original function any-fn is unchanged and not constrained in any way

(will-work any-fn {:a 1 :b 2 :c 3})
(will-work any-fn [1 2 3])
(will-work any-fn :a)
(will-work any-fn 99)
</pre>
</div>

<blockquote>
<p>
The map? predicate in the above call to <span class="underline">apply-contract-aspects</span> is  the <b>Contract Definition</b>.
</p>
</blockquote>

<p>
Under the covers, <span class="underline">apply-contract-aspects</span> generates a <b>CCC</b> contract of form below
where the <span class="underline">ctx-aspect2721</span> is the random, but unique, name (gensym) of
the contract function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - example of the generated clojure.core.contract call
(clojure.core.contracts/contract ctx-aspect2721 "\"ctx-aspect2721\"" [arg0] [(map? arg0)])
</pre>
</div>

<blockquote>
<p>
Quick note on argument names: the arguments to a generated contract
are given names <span class="underline">arg0</span>, <span class="underline">arg1</span>, etc. These names can use used to
 refer explicitly to individual arguments. More on this later.
</p>
</blockquote>

<p>
Similarly, to suck a vector:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - suck a vector

(def suck-vector-fn1 (apply-contract-aspects (fn [x] x) vector?))

(will-work suck-vector-fn1 [1 2 3])

(will-fail suck-vector-fn1 99)
</pre>
</div>

<blockquote>
<p>
Built-in mnemonics provide a simple way of applying the same  assertion to both the input argument and return value - see later.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Example - applying your own custom predicate</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
You can use your own <b>custom</b> predicate function, returning true or false as
decided.  You can constrain multiple input arguments and/or the return
value in a custom predicate.
</p>

<p>
A simple way to create a custom predicate would be to use [:pre and post assertions][FogusBlogClojurePreandPost] 
in an identity function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - applying your own custom predicate

;; The custom predicate ensures the argument is a map, its keys are keywords and values are numbers.

(defn is-map-with-keyword-keys-and-numeric-values?
  [x]
  {:pre [(map? x) (every? keyword? (keys x)) (every? number? (vals x))]}
  x)

(def map-keyword-keys-numeric-values-fn1 (apply-contract-aspects any-fn is-map-with-keyword-keys-and-numeric-values?))

;; This will work

(will-work map-keyword-keys-numeric-values-fn1 {:a 1 :b 2 :c 3})

;; But these will fail the contracts

(will-fail map-keyword-keys-numeric-values-fn1 {:a :x :b 2 :c 3})
(will-fail map-keyword-keys-numeric-values-fn1 {"x" 1 :b 2 :c 3})
(will-fail map-keyword-keys-numeric-values-fn1 [1 2 3])

;; As before the original function any-fn is unchanged and not constrained in any way

(will-work any-fn {:a 1 :b 2 :c 3})
(will-work any-fn [1 2 3])
(will-work any-fn :a)
(will-work any-fn 99)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Using update-contract-aspects</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The second macro, <span class="underline">update-contract-aspect</span>, "changes" (using
<span class="underline">alter-var-root</span>) an existing function.  
</p>
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> Example - updating a function with a built-in predicate</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Essentially the same example as above except the source function but <span class="underline">any-fn</span> is "changed" to <b>only</b> suck a map.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - updating a function with a built-in predicate

;; any-fn is "changed" to now only suck a map

(update-contract-aspects any-fn map?)

;; This will work

(will-work any-fn {:a 1 :b 2 :c 3})

;; But this will fail as any-fn can now only suck a map

(will-fail any-fn [1 2 3])
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Applying Constraints to Multiple Arguments and the Return Value</h2>
<div class="outline-text-2" id="text-5">
<p>
Many functions will have more than one argument, 
even different arities, each
likely requiring its own specific assertions, and the (spit) result
maybe different assertion(s) again.
</p>

<p>
To support a rich definition of the assertions required by each argument and the return value, 
the contract definition can  be specified as a map with two keys: <span class="underline">:suck</span>
and <span class="underline">:spit</span> where the value of the keys are the assertions to apply to
the input arguments and return values. An example should clarify.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Example - suck a map and keyword and spit a vector</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The below defines a two argument contract: the first argument
a map, the second a keyword; with a vector expected as the
result:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{:suck [map? keyword?] :spit vector?}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - suck a map and keyword and spit a vector

;; In this example, the assertion constrains the function to suck a map and keyword
;; and spit a vector.  

;; The function looks up the value of the keyword in the map.

(def suck-map-keyword-spit-vector-fn1 (apply-contract-aspects (fn [m k] (k m)) {:suck [map? keyword?] :spit vector?}))

;; This will work as key :c contains a vector

(will-work suck-map-keyword-spit-vector-fn1 {:a 1 :b 2 :c [1 2 3]} :c)

;; But these will fail

(will-fail suck-map-keyword-spit-vector-fn1 {:a 1 :b 2 :c 3} :c)
(will-fail suck-map-keyword-spit-vector-fn1 {:a 1 :b 2 :c 3} :d)
</pre>
</div>

<p>
Some notes:
</p>

<ul class="org-ul">
<li>assertions are matched positionally to their arguments
</li>
</ul>

<p>
The <span class="underline">map?</span> constrains <b>only</b> the first argument (arg0) and the
<span class="underline">keyword?</span> constrains <b>only</b> the second argument (arg1), and the returned value must be a <span class="underline">vector?</span>.
</p>

<ul class="org-ul">
<li>if there is only one argument, the enclosing vector is not needed
</li>
</ul>

<p>
Just as the return value can be specified as just <span class="underline">vector?</span> and not
<span class="underline">[vector?]</span>, if the function only sucked a map <span class="underline">:suck map?</span> would be sufficient e.g. <span class="underline">{:suck map? :spit vector?}</span>.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Example - suck a map - with keyword keys and numeric values - and keyword and spit a vector</h3>
<div class="outline-text-3" id="text-5-2">
<p>
To include additional constraints on the map in the previous example to
insist on keyword keys and numeric values, the assertion for the map
argument would be changed to a vector of constraints.  
</p>

<p>
Note the use of
<span class="underline">arg0</span> to refer to the input map in the <span class="underline">every?</span> clauses.
</p>

<div class="org-src-container">

<pre class="src src-clojure">{:suck [[map? (every? keyword? (keys arg0)) (every? number? (vals arg0))] keyword?] :spit vector?}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - suck a map - with keyword keys and numeric values - and keyword and spit a vector

;; In this example, the contract constrains the function to suck a map and keyword, spit a number.

;; The map must have keywords keys and numeric values.

(def suck-map-keyword-spit-number-fn1 (apply-contract-aspects (fn [m k] (k m)) {:suck [[map? (every? keyword? (keys arg0)) (every? number? (vals arg0))] keyword?] :spit number?}))

;; This will work

(will-work suck-map-keyword-spit-number-fn1 {:a 1 :b 2 :c 3} :a)

;; But these will fail their contracts

(will-fail suck-map-keyword-spit-number-fn1 {:a :x :b 2 :c 3} :a)
(will-fail suck-map-keyword-spit-number-fn1 {:a 1 :b 2 :c 3} :d)
(will-fail suck-map-keyword-spit-number-fn1 {"x" 1 :b 2 :c 3} :c)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Using CCC's contract definition form</h2>
<div class="outline-text-2" id="text-6">
<p>
For those familiar with <b>CCC</b>, you can also use <b>CCC's</b> contract specification format as well.
But note the signature vector (e.g. '[v]) and assertion vector (e.g.
'[map?]) must be inside a third  vector:
</p>

<div class="org-src-container">

<pre class="src src-clojure">[[v] [map?]]
</pre>
</div>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Example - Using CCC's format to suck a map and spit a vector</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The assertion vector can have any constraints supported by <b>CCC</b>.  For example, here the constrained function
below sucks a map and spits a vector:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - suck map and spit vector using CCC form

(def suck-map-spit-vector-fn1 (apply-contract-aspects (fn [m] (:c m)) [[v] [map? =&gt; vector?]]))

(will-work suck-map-spit-vector-fn1 {:a 1 :b 2 :c [1 2 3]})

(will-fail suck-map-spit-vector-fn1 {:a 1 :b 2 :c 1})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Example - Using CCC's format to suck a map with keyword keys, and spit a vector</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Or, additionally, to ensure the map's keys are all keywords:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - suck map, spit vector but also all map keys are keywords

(def suck-map-keyword-keys-fn1 (apply-contract-aspects (fn [m] (:c m)) [[v] [map? (every? keyword? (keys v)) =&gt; vector?]]))

(will-work suck-map-keyword-keys-fn1 {:a 1 :b 2 :c [1 2 3]})

(will-fail suck-map-keyword-keys-fn1 {"x" 1 :b 2 :c 1})
</pre>
</div>

<p>
The example below will fail becuase the keys of <span class="underline">test-map2</span> are not keywords:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - this will fail as test-map2's keys are not keywords

;;(suck-map-keyword-keys-fn1 test-map2)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Example - using CCC's format with a complicated assertions</h3>
<div class="outline-text-3" id="text-6-3">
<p>
<b>CCC</b>  supports he specification of complicated
assertions. For a two argument function (map, keyword), where the map's
keys are keywords, the values numbers; and the return value
unconstrained, in CCC's format, the assertion would look like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">[[m k] [(map? m) (every? keyword (keys m)) (every? number? (vals m)) (keyword? k)]]
</pre>
</div>

<p>
An example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - using CCC's format to specify multiple assertions

;; In this example, the assertion constrains the function to suck a map,
;; with keywords keys and numeric values, and a keyword.

;; The returned value is unconstrained

(def map-keyword-keys-numeric-vals-fn2 (apply-contract-aspects (fn [m k] (k m)) [[m k] [(map? m) (every? keyword (keys m)) (every? number? (vals m)) (keyword? k)]]))

;; This will work and return nil as the return value is not constrained

(will-work map-keyword-keys-numeric-vals-fn2 {:a 1 :b 2 :c 3} :d)

(will-fail map-keyword-keys-numeric-vals-fn2 {:a 1 :b 2 :c 3} "d")
(will-fail map-keyword-keys-numeric-vals-fn2 {:a :x :b 2 :c 3} :a)
(will-fail map-keyword-keys-numeric-vals-fn2 {"x" 1 :b 2 :c 3} :d)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Using Mnemonics</h2>
<div class="outline-text-2" id="text-7">
<p>
Mnemonic keywords are a way of using short-hand in and for the contract definition(s).
</p>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Using Mnemonics for Built-in Predicates</h3>
<div class="outline-text-3" id="text-7-1">
<p>
So far the assertions used have been built-in predicates such as <span class="underline">map?</span>,
<span class="underline">number?</span> and <span class="underline">vector?</span> but we could have used their keyword mnemonics
<span class="underline">:map</span>, <span class="underline">:number</span> or <span class="underline">:vector</span>.  In fact any predicate of the form
<span class="underline">name?</span> can be replaced by its keyword form <span class="underline">:name</span> (as long as the
symbol can be <b>resolved</b>).
</p>
</div>

<div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> Example - using a built-in mnemonic</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
To repeat the example above using <span class="underline">map?</span> but with <span class="underline">:map</span>:
</p>

<blockquote>
<p>
Note: using a built-in mnemonic as the full contract definition will apply the assertion(s) to both the input argument and also return value.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - using a built-in mnemonic

;; This is a contrived example to show the constraint symmetry when using a buit-in mnemonic.
;; The function hard-codes a map as it return value so will always satisfy the spit constraint.

(def mnemonic-suck-and-spit-map-fn1 (apply-contract-aspects (fn [x] {:x 1 :y 2 :z 3}) :map))

;; This will work because the argument is a map and the (hard-coded) return value is a map

(will-work mnemonic-suck-and-spit-map-fn1 {:a 1 :b 2 :c 3})

;; But this fail sicne the argument is not a map

(will-fail mnemonic-suck-and-spit-map-fn1 [1 2 3])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2"><span class="section-number-4">7.1.2</span> Example - using targeted built-in mnemonics</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
Repeating one of the example above, all that has changed is the
assertion now  uses keywords.
</p>

<blockquote>
<p>
Note: using built-in mnemonics in the map form of a contract
definition make the assertion only apply to the mnemonic's respective
argument.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - using targeted built-in mnemonics

;; In this example, built-in mnemonics are used to constrains the
;; function to suck a map and keyword and spit a vector.

(def suck-map-keyword-spit-vector-fn1 (apply-contract-aspects (fn [m k] (k m)) {:suck [:map :keyword] :spit :vector}))

;; This will work as key :c contains a vector

(will-work suck-map-keyword-spit-vector-fn1 {:a 1 :b 2 :c [1 2 3]} :c)

;; But these will fail their contract

(will-fail suck-map-keyword-spit-vector-fn1 {:a 1 :b 2 :c 3} :c)
(will-fail suck-map-keyword-spit-vector-fn1 {:a 1 :b 2 :c 3} :d)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Changing a Built-in Mnemonic Contract Definition</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Replacing a built-in predicate with its keyword mnemonic is not a big win,
just saving a few characters in the assertion definition. 
</p>

<p>
The real power 0of
mnemonics comes from the opportunity to change the definition of an
existing mnemonic (or add custom ones - see later).
</p>

<p>
Another macro will update mnemonic definitions: <span class="underline">configure-contracts-store</span>
</p>
</div>

<div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1"><span class="section-number-4">7.2.1</span> Example - re-defining the :map built-in mnemonic</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
Say you wanted to re-define the built-in <span class="underline">:map</span> mnemonic to also check the keys are keywords:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Changing a Built-in Mnemonic Contract Definition

;; Change the built-in :map mnemonics to also check the keys are keywords

(configure-contracts-store aspect-mnemonics {:map {:suck [[map? (every? keyword? (keys arg0))]]}})
</pre>
</div>

<p>
Using the updated mnemonic is exactly the same as before, albeit with
the additional constraints applied:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - re-defining the :map built-in mnemonic

;; In this example, the :map built-in mnemonic has been changed to check the keys are keywords.

(def suck-map-keyword-spit-vector-fn1 (apply-contract-aspects (fn [m k] (k m)) {:suck [:map :keyword] :spit :vector}))

;; This will work as key :c contains a vector

(will-work suck-map-keyword-spit-vector-fn1 {:a 1 :b 2 :c [1 2 3]} :c)

;; But this will fail the contract as "x" is not a keyword.

(will-fail suck-map-keyword-spit-vector-fn1 {"x" 1 :b 2 :c 3} :c)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Adding and Using Custom Mnemonics</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Just as you can update the definition of a built-in mnemonic, you can
add / update your own <b>custom</b> mnemonics.
</p>
</div>

<div id="outline-container-sec-7-3-1" class="outline-4">
<h4 id="sec-7-3-1"><span class="section-number-4">7.3.1</span> Example - using a custom mnemonic</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
Say you wanted to define a custom mnemonic that "packages" the constraints
that a map's keys are keywords and all the values are numeric:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - add a new mnemonic to the contracts store

;; The new mnemonic - :map-keyword-keys-numeric-vals - constrains an
;; argument to be a map with keyword keys and numeric values.

(configure-contracts-store
 aspect-mnemonics
 {:map-keyword-keys-numeric-vals {:suck [[map? (every? keyword? (keys arg0)) (every? number? (vals arg0))]]}})
</pre>
</div>

<p>
To use the new mnemonic is straightforward.  Note the mnemonic appears
as the first value in the <span class="underline">:suck</span> assertion vector, the other entry
being <span class="underline">:keyword</span>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - using a custom mnemonic

;; In this example, the assertion constrains the function to suck a map and keyword, spit a number.

;; The map must have keywords keys and numeric values.

(def mnemonic-suck-map-keyword-spit-number-fn1 (apply-contract-aspects (fn [m k] (k m)) {:suck [:map-keyword-keys-numeric-vals  :keyword] :spit :number}))

;; This will work

(will-work mnemonic-suck-map-keyword-spit-number-fn1 {:a 1 :b 2 :c 3} :a)

;; But these will fail their contracts

(will-fail mnemonic-suck-map-keyword-spit-number-fn1 {:a :x :b 2 :c 3} :a)
(will-fail mnemonic-suck-map-keyword-spit-number-fn1 {:a 1 :b 2 :c 3} :d)
(will-fail mnemonic-suck-map-keyword-spit-number-fn1 {"x" 1 :b 2 :c 3} :c)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Using a Custom Mnemonic to package multiple arguments</h3>
<div class="outline-text-3" id="text-7-4">
<p>
You can go a step farther from the previous example and add the requirement for the second
argument to be a keyword into the mnemonic as well:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Using a Custom Mnemonic to package multiple arguments

;; The new mnemonic combines the assertions to ensure the first argument
;; is a map with keyword keys and numerics value and also the requirement
;; for the second argument to be a keyword.

(configure-contracts-store aspect-mnemonics {:suck-map-keyword-keys-numeric-vals-and-keyword {:suck [[map? (every? keyword? (keys arg0)) (every? number? (vals arg0))] keyword?]}})
</pre>
</div>
</div>

<div id="outline-container-sec-7-4-1" class="outline-4">
<h4 id="sec-7-4-1"><span class="section-number-4">7.4.1</span> Example - using a custom multiple argument suck mnemonic</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
In this example a multiple argument mnemonic replaces the whole <span class="underline">:suck</span> definition.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - using a custom multiple argument suck mnemonic

;; In this example, the map assertion uses a mnemonic to ensure keywords keys and numeric values.

(def mnemonic-suck-map-keyword-spit-number-fn2 (apply-contract-aspects (fn [m k] (k m)) {:suck :suck-map-keyword-keys-numeric-vals-and-keyword :spit :number}))

;; Using the same tests as above

(will-work mnemonic-suck-map-keyword-spit-number-fn2 {:a 1 :b 2 :c 3} :a)
(will-fail mnemonic-suck-map-keyword-spit-number-fn2 {:a :x :b 2 :c 3} :a)
(will-fail mnemonic-suck-map-keyword-spit-number-fn2 {:a 1 :b 2 :c 3} :d)
(will-fail mnemonic-suck-map-keyword-spit-number-fn2 {"x" 1 :b 2 :c 3} :c)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> Using a Custom Mnemonic to package the complete contract</h3>
<div class="outline-text-3" id="text-7-5">
<p>
Its just a small step from the multi argument example to packaging
the whole contract in a custom mnemonic:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Using a Custom Mnemonic to package the complete contract

;; The custom mnemonic combines the assertions to ensure the first
;; argument is a map with keyword keys and numerics value and also the
;; requirement for the second argument to be a keywork. It also includes
;; the requirement for the return value to be a number.

(configure-contracts-store
 aspect-mnemonics
 {:contract-suck-map-keyword-keys-numeric-vals-and-keyword-spit-number 
  {:suck [[map? (every? keyword? (keys arg0)) (every? number? (vals arg0))] keyword?] :spit :number}})
</pre>
</div>
</div>

<div id="outline-container-sec-7-5-1" class="outline-4">
<h4 id="sec-7-5-1"><span class="section-number-4">7.5.1</span> Example - using a custom mnemonic to package the whole contract</h4>
<div class="outline-text-4" id="text-7-5-1">
<p>
In this example the complete contract mnemonic replaces the whole
contract map form.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - using a custom mnemonic to package the whole contract

;; In this example, the a mnemonic packages the complete assertion

(def mnemonic-suck-map-keyword-spit-number-fn3 
  (apply-contract-aspects (fn [m k] (k m)) :contract-suck-map-keyword-keys-numeric-vals-and-keyword-spit-number))

;; Exactly the same tests as above

(will-work mnemonic-suck-map-keyword-spit-number-fn3 {:a 1 :b 2 :c 3} :a)
(will-fail mnemonic-suck-map-keyword-spit-number-fn3 {:a :x :b 2 :c 3} :a)
(will-fail mnemonic-suck-map-keyword-spit-number-fn3 {:a 1 :b 2 :c 3} :d)
(will-fail mnemonic-suck-map-keyword-spit-number-fn3 {"x" 1 :b 2 :c 3} :c)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> Using Mnemonics in Custom Mnemonics</h3>
<div class="outline-text-3" id="text-7-6">
<p>
You can use mnemonics in the <b>composition</b>  of other, richer mnemonics (although
beware the infinite recursion gotcha mentioned below).
</p>

<p>
For example, create a custom mnemonic to constrain a map to have
keyword keys and numeric values, and use that mnemonic in another
mnemonic to include the keyword as the second arguments. And use the
second mnemonic to specify the contract for a two argument function taking
the constrained map and a
keyword, and returning a number.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Using Mnemonics in Custom Mnemeonics

;; The first customer mnemonic constrains a map to have keyword keys and numeric values.

;; The second custome mnemonic speficiy the constrained map and a keyword as the seocnd argument.

;; The third custom mnemonic uses the second mnemonic to build a
;; complete contract mnemonic for a two argument function sucking the
;; constrained map and a keyword, and returning a number.

(configure-contracts-store
 aspect-mnemonics
 {

  :suck-map-keyword-keys-numeric-vals 
  {:suck [[map? (every? keyword? (keys arg0)) (every? number? (vals arg0))]]}

  :suck-map-keyword-keys-numeric-vals-and-keyword
  {:suck [:suck-map-keyword-keys-numeric-vals :keyword]}

  :contract-suck-map-keyword-keys-numeric-vals-and-keyword-spit-number 
  {:suck :suck-map-keyword-keys-numeric-vals-and-keyword :spit :number}

  })
</pre>
</div>
</div>


<div id="outline-container-sec-7-6-1" class="outline-4">
<h4 id="sec-7-6-1"><span class="section-number-4">7.6.1</span> Example - using a mnemonic containing mnemonics</h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
The example is exactly the same as the one above, the use of "sub"
mnemonic is invisible.:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - using a mnemonic containing mnemonics

;; In this example, the three level mnemonic packages the complete assertion

(def mnemonic-suck-map-keyword-spit-number-fn3 (apply-contract-aspects (fn [m k] (k m)) :contract-suck-map-keyword-keys-numeric-vals-and-keyword-spit-number ))

;; Exactly the same tests as above

(will-work mnemonic-suck-map-keyword-spit-number-fn3 {:a 1 :b 2 :c 3} :a)
(will-fail mnemonic-suck-map-keyword-spit-number-fn3 {:a :x :b 2 :c 3} :a)
(will-fail mnemonic-suck-map-keyword-spit-number-fn3 {:a 1 :b 2 :c 3} :d)
(will-fail mnemonic-suck-map-keyword-spit-number-fn3 {"x" 1 :b 2 :c 3} :c)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-6-2" class="outline-4">
<h4 id="sec-7-6-2"><span class="section-number-4">7.6.2</span> Beware mnemonic gotchas</h4>
<div class="outline-text-4" id="text-7-6-2">
<p>
The code tries to be as aggressive as possible to catch
inconsistencies and ensure your get what
you want. But there are some things to be aware of
</p>
</div>

<div id="outline-container-sec-7-6-2-1" class="outline-5">
<h5 id="sec-7-6-2-1"><span class="section-number-5">7.6.2.1</span> Beware mnemonic gotchas - infinite recursion</h5>
<div class="outline-text-5" id="text-7-6-2-1">
<p>
Because mnemonics can use other mnemonic in their definition there is the
ability to create an infinite loop if a "downstream" mnemonic refers to
an "upstream" one.
</p>

<p>
<span class="underline">It would be possible to "remember" used mnemonics during evaluation
but not done so yet.</span>
</p>
</div>
</div>
<div id="outline-container-sec-7-6-2-2" class="outline-5">
<h5 id="sec-7-6-2-2"><span class="section-number-5">7.6.2.2</span> Beware mnemonic gotchas - incompatible argument constraints</h5>
<div class="outline-text-5" id="text-7-6-2-2">
<p>
If a custom mnemonic's argument assertions conflict with an explicit predicate,
regular mnemonic (e.g. :map) or another custom mnemonic, the contract
will include more than one, but potentially differnt
constraints for the same argument.  Which will fail miserably.
</p>

<p>
Note though duplicate assertions will be <b>distinct</b>-ified and cause no issue. 
</p>
</div>
</div>
<div id="outline-container-sec-7-6-2-3" class="outline-5">
<h5 id="sec-7-6-2-3"><span class="section-number-5">7.6.2.3</span> Beware mnemonic gotchas - unexpected arguments</h5>
<div class="outline-text-5" id="text-7-6-2-3">
<p>
If a custom mnemonic for two arguments is applied to a function with
e.g. only one, an error will occur at run time.
</p>
</div>
</div>
<div id="outline-container-sec-7-6-2-4" class="outline-5">
<h5 id="sec-7-6-2-4"><span class="section-number-5">7.6.2.4</span> Beware mnemonic gotchas - rewriting mnemonics</h5>
<div class="outline-text-5" id="text-7-6-2-4">
<p>
Not a gotcah but coud catch unawares
</p>

<p>
to match argument numbers
</p>

<p>
e.g. the every clauses arg0
</p>

<p>
NEED TO CHECK CODE WHEN MNEMONIC IS USED FOR AGUMNET NO 1 or GREATER ADN REWRITE arg0, etc to arg0 + n
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Contracts with Multiple Arities</h2>
<div class="outline-text-2" id="text-8">
<p>
<b>CCC</b> support applying contracts to functions with multiple arities.
<b>CHUGAR</b> supports the definition of multiple arities, just put them
all in a vector on the call to e.g. <span class="underline">apply-contract-aspects</span>.
</p>

<p>
<b>CHUGAR</b> raises an error if it identifies  contracts with the same
arity for the same function in the same call.
</p>
</div>

<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> Example - two arities (map =&gt; number) and (map,keyword =&gt; vector)</h3>
<div class="outline-text-3" id="text-8-1">
<p>
This example of a multiple arities contract defines one arity for a single argument
function that suck a map and returns a vector; and a second arity for
a two argument function that sucks a map and keyword and spits a
vector.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - two arities (map =&gt; number) and (map,keyword =&gt; number)

;; This is the targer function with twop arities

(defn two-arity-fn1
  ([m] (:a m))
  ([m k] (k m)))

;; The constrained function

(def constrained-two-arity-fn1 (apply-contract-aspects two-arity-fn1 [{:suck :map :spit :number} {:suck [:map :keyword] :spit :vector}]))

;; First Arity Tests

;; This will works as value of key :a is a number

(will-work constrained-two-arity-fn1 {:a 1 :b 2 :c [1 2 3]})

; This will fail as value of key :a is not a number

(will-fail constrained-two-arity-fn1 {:a "x"})

;; Second Arity Tests

;; This will work as value of key :c is a vector

(will-work constrained-two-arity-fn1 {:a 1 :b 2 :c [1 2 3]} :c)

; This will fail as value of key :d is not a vector (its nil)

(will-fail constrained-two-arity-fn1 {:a "x"} :d)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Example - multiple arities using mixed CCC form and map form</h3>
<div class="outline-text-3" id="text-8-2">
<p>
The definition of the contract for each arity can be either CCC form
or map form; they can be mixed as well.
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; Example - multiple arities using mixed CCC form and map form 

;; The same multiple arity example as above but using a mixed contract definition with CCC form and map form.

(def constrained-two-arity-fn1 (apply-contract-aspects two-arity-fn1 [[[m] [map? =&gt; number?]]  {:suck [:map :keyword] :spit :vector}]))

;; First Arity Tests

;; This will works as value of key :a is a number

(will-work constrained-two-arity-fn1 {:a 1 :b 2 :c [1 2 3]})

; This will fail as value of key :a is not a number

(will-fail constrained-two-arity-fn1 {:a "x"})

;; Second Arity Tests

;; This will work as value of key :c is a vector

(will-work constrained-two-arity-fn1 {:a 1 :b 2 :c [1 2 3]} :c)

; This will fail as value of key :d is not a vector (its nil)

(will-fail constrained-two-arity-fn1 {:a "x"} :d)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Final Words</h2>
<div class="outline-text-2" id="text-9">
<p>
Writing <b>CHUGAR</b> has taught me a lot about writing
[Clojure][ClojureHome] (notably macros and protocols) but I still have lots to learn.
</p>

<p>
So I'm sure more experienced Clojurians will have <span class="underline">wtf?</span> moments if they
look at the code.  As I tweeted recently, I think the biggest challenge
to learning a new language is to design idiomatically and well in it.
All advice on that subject gratefully received and acknowledged.
</p>

<p>
The whole point of <b>CHUGAR</b> was/is to make using the rich features of
<b>CCC</b> as easy as possible.  I hope it (begins to) succeed on that
criterion and I further hope <span class="underline">mnemonics</span> offers an original  useful
productivity aid for defining and re-using contract aspects.
</p>

<p>
I already have another article in the works on the practical use of
<b>CHUGAR</b> to constrain the value of map keys with aspects.  Coming soon!
</p>

<pre class="example">
[ClojureHome]: http:///clojure.org
[JavaHome]: http://www.java.com
[LeiningenHome]: http://leiningen.org/
[LeiningenGithub]: https://github.com/technomancy/leiningen
[MavenHome]: http://maven.apache.org/
[ClojarsHome]: http://clojars.org
[ClojureCoreContractsGithub]: https://github.com/clojure/core.contracts
[ClojureContractsSugarGithub]: https://github.com/ianrumford/clojure-contracts-sugar
[ClojureCarpGithub]: https://github.com/ianrumford/clojure-carp
[RumfordBlogClojureCoreContractsFirstTake]: http://ianrumford.github.io/blog/2012/11/17/first-take-on-contracts-in-clojure/
[FogusHome]: http://blog.fogus.me
[FogusBlogClojurePreandPost]: http://blog.fogus.me/2009/12/21/clojures-pre-and-post/
[Eiffel Design by Contract]: http://en.wikipedia.org/wiki/Eiffel_(programming_language)#Design_by_Contract
[DesignByContractWikipedia]: http://en.wikipedia.org/wiki/Design_by_contract
[CACMOct2001]:  http://dl.acm.org/citation.cfm?id=383845
[CACMArticleAOPIntro]: http://dl.acm.org/citation.cfm?id=383845.383853&amp;coll=portal&amp;dl=ACM
[AOPWikipedia]: http://en.wikipedia.org/wiki/Aspect-oriented_programming
[LaddadBookAspectJinAction]: http://www.manning.com/laddad/
[LaddadTwitter]: https://twitter.com/ramnivas
[KiczalesHome]: http://people.cs.ubc.ca/~gregor/
[EmerickHome]: http://cemerick.com/
[GrandHome]: http://clj-me.cgrand.net/
[CarperHome]: http://briancarper.net/
[ClojureProgrammingBook]: http://www.clojurebook.com/
[emacshome]: http://www.gnu.org/software/emacs/
[orgmodehome]: http://orgmode.org/
[orgmodemanualextractsourcecode]: http://orgmode.org/org.html#Extracting-source-code
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Ian Rumford</p>
<p class="date">Created: 2014-01-30 Thu 18:41</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5c)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
